diff --git a/aten/src/ATen/native/mkldnn/Normalization.cpp b/aten/src/ATen/native/mkldnn/Normalization.cpp
index f9641bc..45d8ada 100644
--- a/aten/src/ATen/native/mkldnn/Normalization.cpp
+++ b/aten/src/ATen/native/mkldnn/Normalization.cpp
@@ -176,34 +176,54 @@ std::tuple<Tensor, Tensor, Tensor> mkldnn_batch_norm_relu_backward(
     double eps,
     std::array<bool,3> grad_input_mask,
     bool fuse_relu) {
-  TORCH_CHECK(train, "mkldnn_batch_norm_backward: currently mkldnn only support train model");
   ideep::tensor& grady = itensor_from_mkldnn(grad_output);
   ideep::tensor& x = itensor_from_mkldnn(input);
   ideep::tensor w = itensor_from_tensor(weight);
-  ideep::tensor& m = itensor_from_mkldnn(save_mean);
-  ideep::tensor& v = itensor_from_mkldnn(save_invstd);
 
   ideep::tensor gradx, gradw, gradb;
-  if (fuse_relu) {
-    ideep::tensor& y = itensor_from_mkldnn(output);
-    auto flags = ideep::batch_normalization_flag::fuse_norm_relu;
-    ideep::batch_normalization_backward::compute(
-        x, m, v, grady, w, gradx, gradw, gradb, eps, y, flags);
+  if (train) {
+    ideep::tensor& m = itensor_from_mkldnn(save_mean);
+    ideep::tensor& v = itensor_from_mkldnn(save_invstd);
+    if (fuse_relu) {
+      ideep::tensor& y = itensor_from_mkldnn(output);
+      auto flags = ideep::batch_normalization_flag::fuse_norm_relu;
+      ideep::batch_normalization_backward::compute(
+          x, m, v, grady, w, gradx, gradw, gradb, eps, y, flags);
+    } else {
+      ideep::batch_normalization_backward::compute(
+          x, m, v, grady, w, gradx, gradw, gradb, eps);
+    }
   } else {
+    ideep::tensor& m = itensor_from_mkldnn(running_mean);
+    ideep::tensor& v = itensor_from_mkldnn(running_var);
     ideep::batch_normalization_backward::compute(
-        x, m, v, grady, w, gradx, gradw, gradb, eps);
+        x, m, v, grady, w, gradx, eps);
   }
 
   if (weight.is_mkldnn()) {
-    return std::make_tuple(
-        new_with_itensor_mkldnn(std::move(gradx), input.options()),
-        new_with_itensor_mkldnn(std::move(gradw), weight.options()),
-        new_with_itensor_mkldnn(std::move(gradb), weight.options()));
+    if (train) {
+      return std::make_tuple(
+          new_with_itensor_mkldnn(std::move(gradx), input.options()),
+          new_with_itensor_mkldnn(std::move(gradw), weight.options()),
+          new_with_itensor_mkldnn(std::move(gradb), weight.options()));
+    } else {
+      return std::make_tuple(
+          new_with_itensor_mkldnn(std::move(gradx), input.options()),
+          new_with_itensor_mkldnn(ideep::tensor{}, weight.options()),
+          new_with_itensor_mkldnn(ideep::tensor{}, weight.options()));
+    }
   } else {
-    return std::make_tuple(
-        new_with_itensor_mkldnn(std::move(gradx), input.options()),
-        mkldnn_to_dense(new_with_itensor_mkldnn(std::move(gradw), weight.options())),
-        mkldnn_to_dense(new_with_itensor_mkldnn(std::move(gradb), weight.options())));
+    if (train) {
+      return std::make_tuple(
+          new_with_itensor_mkldnn(std::move(gradx), input.options()),
+          mkldnn_to_dense(new_with_itensor_mkldnn(std::move(gradw), weight.options())),
+          mkldnn_to_dense(new_with_itensor_mkldnn(std::move(gradb), weight.options())));
+    } else {
+      return std::make_tuple(
+          new_with_itensor_mkldnn(std::move(gradx), input.options()),
+          mkldnn_to_dense(new_with_itensor_mkldnn(ideep::tensor{}, weight.options())),
+          mkldnn_to_dense(new_with_itensor_mkldnn(ideep::tensor{}, weight.options())));
+    }
   }
 }
 

